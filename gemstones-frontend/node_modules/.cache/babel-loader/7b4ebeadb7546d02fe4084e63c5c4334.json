{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport Web3 from \"web3\";\nimport web3CoreSubscriptions from \"web3-core-subscriptions\";\nimport { decodeParameter } from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport { formatBlock } from \"./util/hex\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthFeeHistoryMethod } from \"./web3-adapter/eth_feeHistory\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\nvar DEFAULT_MAX_RETRIES = 3;\nvar DEFAULT_RETRY_INTERVAL = 1000;\nvar DEFAULT_RETRY_JITTER = 250;\nexport var AssetTransfersCategory;\n\n(function (AssetTransfersCategory) {\n  AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n  AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n  AssetTransfersCategory[\"TOKEN\"] = \"token\";\n})(AssetTransfersCategory || (AssetTransfersCategory = {}));\n\nexport function createAlchemyWeb3(alchemyUrl, config) {\n  var fullConfig = fillInConfigDefaults(config);\n\n  var _a = makeAlchemyContext(alchemyUrl, fullConfig),\n      provider = _a.provider,\n      senders = _a.senders,\n      setWriteProvider = _a.setWriteProvider;\n\n  var alchemyWeb3 = new Web3(provider);\n\n  alchemyWeb3.setProvider = function () {\n    throw new Error(\"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\");\n  };\n\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: function (params, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params]\n      });\n    },\n    getTokenBalances: function (address, contractAddresses, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses],\n        processResponse: processTokenBalanceResponse\n      });\n    },\n    getTokenMetadata: function (address, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\"\n      });\n    },\n    getAssetTransfers: function (params, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        params: [__assign(__assign({}, params), {\n          fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n          toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n          maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n        })],\n        method: \"alchemy_getAssetTransfers\"\n      });\n    }\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthFeeHistoryMethod(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.writeProvider,\n      writeProvider = _c === void 0 ? getWindowProvider() : _c,\n      _d = _b.maxRetries,\n      maxRetries = _d === void 0 ? DEFAULT_MAX_RETRIES : _d,\n      _e = _b.retryInterval,\n      retryInterval = _e === void 0 ? DEFAULT_RETRY_INTERVAL : _e,\n      _f = _b.retryJitter,\n      retryJitter = _f === void 0 ? DEFAULT_RETRY_JITTER : _f;\n\n  return {\n    writeProvider: writeProvider,\n    maxRetries: maxRetries,\n    retryInterval: retryInterval,\n    retryJitter: retryJitter\n  };\n}\n\nfunction getWindowProvider() {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\nfunction callAlchemyMethod(_a) {\n  var _this = this;\n\n  var senders = _a.senders,\n      method = _a.method,\n      params = _a.params,\n      _b = _a.callback,\n      callback = _b === void 0 ? noop : _b,\n      _c = _a.processResponse,\n      processResponse = _c === void 0 ? identity : _c;\n\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , senders.send(method, params)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , processResponse(result)];\n        }\n      });\n    });\n  }();\n\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(rawResponse) {\n  // Convert token balance fields from hex-string to decimal-string.\n  var fixedTokenBalances = rawResponse.tokenBalances.map(function (balance) {\n    return balance.tokenBalance != null ? __assign(__assign({}, balance), {\n      tokenBalance: decodeParameter(\"uint256\", balance.tokenBalance)\n    }) : balance;\n  });\n  return __assign(__assign({}, rawResponse), {\n    tokenBalances: fixedTokenBalances\n  });\n}\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions.\n */\n\n\nfunction patchSubscriptions(web3) {\n  var eth = web3.eth;\n  var oldSubscribe = eth.subscribe.bind(eth);\n\n  eth.subscribe = function (type) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    if (type === \"alchemy_fullPendingTransactions\" || type === \"alchemy_newFullPendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_newFullPendingTransactions\"], __read(rest)));\n      });\n    }\n\n    if (type === \"alchemy_filteredNewFullPendingTransactions\" || type === \"alchemy_filteredPendingTransactions\" || type === \"alchemy_filteredFullPendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_filteredNewFullPendingTransactions\"], __read(rest)));\n      });\n    }\n\n    return oldSubscribe.apply(void 0, __spreadArray([type], __read(rest)));\n  };\n}\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\n\n\nfunction suppressNoSubscriptionExistsWarning(f) {\n  var oldConsoleWarn = console.warn;\n\n  console.warn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (typeof args[0] === \"string\" && args[0].includes(\" doesn't exist. Subscribing anyway.\")) {\n      return;\n    }\n\n    return oldConsoleWarn.apply(console, args);\n  };\n\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\n\n\nvar subscription = web3CoreSubscriptions.subscription;\nvar oldSubscriptionPrototypeValidateArgs = subscription.prototype._validateArgs;\n\nsubscription.prototype._validateArgs = function (args) {\n  if ([\"alchemy_filteredNewFullPendingTransactions\", \"alchemy_filteredPendingTransactions\", \"alchemy_filteredFullPendingTransactions\"].includes(this.subscriptionMethod)) {// This particular subscription type is allowed to have additional parameters\n  } else {\n    if ([\"alchemy_fullPendingTransactions\", \"alchemy_newFullPendingTransactions\"].includes(this.subscriptionMethod)) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n\n    var validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\n\nfunction noop() {// Nothing.\n}\n\nfunction identity(x) {\n  return x;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import Web3 from \"web3\";\nimport { Log, LogsOptions, Transaction } from \"web3-core\";\nimport web3CoreSubscriptions, { Subscription } from \"web3-core-subscriptions\";\nimport { BlockHeader, Eth, Syncing } from \"web3-eth\";\nimport { decodeParameter } from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport {\n  AlchemyWeb3Config,\n  FullConfig,\n  Provider,\n  TransactionsOptions,\n  Web3Callback,\n} from \"./types\";\nimport { formatBlock } from \"./util/hex\";\nimport { JsonRpcSenders } from \"./util/jsonRpc\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthFeeHistoryMethod } from \"./web3-adapter/eth_feeHistory\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_RETRY_INTERVAL = 1000;\nconst DEFAULT_RETRY_JITTER = 250;\n\nexport interface AlchemyWeb3 extends Web3 {\n  alchemy: AlchemyMethods;\n  eth: AlchemyEth;\n  setWriteProvider(provider: Provider | null | undefined): void;\n}\n\nexport interface AlchemyMethods {\n  getTokenAllowance(\n    params: TokenAllowanceParams,\n    callback?: Web3Callback<TokenAllowanceResponse>,\n  ): Promise<TokenAllowanceResponse>;\n  getTokenBalances(\n    address: string,\n    contractAddresses: string[],\n    callback?: Web3Callback<TokenBalancesResponse>,\n  ): Promise<TokenBalancesResponse>;\n  getTokenMetadata(\n    address: string,\n    callback?: Web3Callback<TokenMetadataResponse>,\n  ): Promise<TokenMetadataResponse>;\n  getAssetTransfers(\n    params: AssetTransfersParams,\n    callback?: Web3Callback<AssetTransfersResponse>,\n  ): Promise<AssetTransfersResponse>;\n}\n\nexport interface TokenAllowanceParams {\n  contract: string;\n  owner: string;\n  spender: string;\n}\n\nexport type TokenAllowanceResponse = string;\n\nexport interface TokenBalancesResponse {\n  address: string;\n  tokenBalances: TokenBalance[];\n}\n\nexport type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;\n\nexport interface TokenBalanceSuccess {\n  address: string;\n  tokenBalance: string;\n  error: null;\n}\n\nexport interface TokenBalanceFailure {\n  address: string;\n  tokenBalance: null;\n  error: string;\n}\n\nexport interface TokenMetadataResponse {\n  decimals: number | null;\n  logo: string | null;\n  name: string | null;\n  symbol: string | null;\n}\n\nexport interface AssetTransfersParams {\n  fromBlock?: string;\n  toBlock?: string;\n  fromAddress?: string;\n  toAddress?: string;\n  contractAddresses?: string[];\n  excludeZeroValue?: boolean;\n  maxCount?: number;\n  category?: AssetTransfersCategory[];\n  pageKey?: string;\n}\n\nexport enum AssetTransfersCategory {\n  EXTERNAL = \"external\",\n  INTERNAL = \"internal\",\n  TOKEN = \"token\",\n}\n\nexport interface AssetTransfersResponse {\n  transfers: AssetTransfersResult[];\n  pageKey?: string;\n}\n\nexport interface AssetTransfersResult {\n  category: AssetTransfersCategory;\n  blockNum: string;\n  from: string;\n  to: string | null;\n  value: number | null;\n  erc721TokenId: string | null;\n  asset: string | null;\n  hash: string;\n  rawContract: RawContract;\n}\n\nexport interface RawContract {\n  value: string | null;\n  address: string | null;\n  decimal: string | null;\n}\n\n/**\n * Same as Eth, but with `subscribe` allowing more types.\n */\nexport interface AlchemyEth extends Eth {\n  subscribe(\n    type: \"logs\",\n    options?: LogsOptions,\n    callback?: (error: Error, log: Log) => void,\n  ): Subscription<Log>;\n  subscribe(\n    type: \"syncing\",\n    callback?: (error: Error, result: Syncing) => void,\n  ): Subscription<Syncing>;\n  subscribe(\n    type: \"newBlockHeaders\",\n    callback?: (error: Error, blockHeader: BlockHeader) => void,\n  ): Subscription<BlockHeader>;\n  subscribe(\n    type: \"pendingTransactions\",\n    callback?: (error: Error, transactionHash: string) => void,\n  ): Subscription<string>;\n  subscribe(\n    type: \"alchemy_fullPendingTransactions\",\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type: \"alchemy_filteredFullPendingTransactions\",\n    options?: TransactionsOptions,\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type:\n      | \"pendingTransactions\"\n      | \"logs\"\n      | \"syncing\"\n      | \"newBlockHeaders\"\n      | \"alchemy_fullPendingTransactions\"\n      | \"alchemy_filteredFullPendingTransactions\",\n    options?: null | LogsOptions | TransactionsOptions,\n    callback?: (\n      error: Error,\n      item: Log | Syncing | BlockHeader | string | Transaction,\n    ) => void,\n  ): Subscription<Log | BlockHeader | Syncing | string>;\n}\n\ninterface EthereumWindow extends Window {\n  ethereum?: any;\n}\n\ndeclare const window: EthereumWindow;\n\nexport function createAlchemyWeb3(\n  alchemyUrl: string,\n  config?: AlchemyWeb3Config,\n): AlchemyWeb3 {\n  const fullConfig = fillInConfigDefaults(config);\n  const { provider, senders, setWriteProvider } = makeAlchemyContext(\n    alchemyUrl,\n    fullConfig,\n  );\n  const alchemyWeb3 = new Web3(provider) as AlchemyWeb3;\n  alchemyWeb3.setProvider = () => {\n    throw new Error(\n      \"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\",\n    );\n  };\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: (params: TokenAllowanceParams, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params],\n      }),\n    getTokenBalances: (address, contractAddresses, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses],\n        processResponse: processTokenBalanceResponse,\n      }),\n    getTokenMetadata: (address, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\",\n      }),\n    getAssetTransfers: (params: AssetTransfersParams, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        params: [\n          {\n            ...params,\n            fromBlock:\n              params.fromBlock != null\n                ? formatBlock(params.fromBlock)\n                : undefined,\n            toBlock:\n              params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n            maxCount:\n              params.maxCount != null ? toHex(params.maxCount) : undefined,\n          },\n        ],\n        method: \"alchemy_getAssetTransfers\",\n      }),\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthFeeHistoryMethod(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults({\n  writeProvider = getWindowProvider(),\n  maxRetries = DEFAULT_MAX_RETRIES,\n  retryInterval = DEFAULT_RETRY_INTERVAL,\n  retryJitter = DEFAULT_RETRY_JITTER,\n}: AlchemyWeb3Config = {}): FullConfig {\n  return { writeProvider, maxRetries, retryInterval, retryJitter };\n}\n\nfunction getWindowProvider(): Provider | null {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\ninterface CallAlchemyMethodParams<T> {\n  senders: JsonRpcSenders;\n  method: string;\n  params: any[];\n  callback?: Web3Callback<T>;\n  processResponse?(response: any): T;\n}\n\nfunction callAlchemyMethod<T>({\n  senders,\n  method,\n  params,\n  callback = noop,\n  processResponse = identity,\n}: CallAlchemyMethodParams<T>): Promise<T> {\n  const promise = (async () => {\n    const result = await senders.send(method, params);\n    return processResponse(result);\n  })();\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(\n  rawResponse: TokenBalancesResponse,\n): TokenBalancesResponse {\n  // Convert token balance fields from hex-string to decimal-string.\n  const fixedTokenBalances = rawResponse.tokenBalances.map((balance) =>\n    balance.tokenBalance != null\n      ? {\n          ...balance,\n          tokenBalance: decodeParameter(\"uint256\", balance.tokenBalance),\n        }\n      : balance,\n  );\n  return { ...rawResponse, tokenBalances: fixedTokenBalances };\n}\n\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions.\n */\nfunction patchSubscriptions(web3: Web3): void {\n  const { eth } = web3;\n  const oldSubscribe = eth.subscribe.bind(eth);\n  eth.subscribe = ((type: string, ...rest: any[]) => {\n    if (\n      type === \"alchemy_fullPendingTransactions\" ||\n      type === \"alchemy_newFullPendingTransactions\"\n    ) {\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\"alchemy_newFullPendingTransactions\" as any, ...rest),\n      );\n    }\n    if (\n      type === \"alchemy_filteredNewFullPendingTransactions\" ||\n      type === \"alchemy_filteredPendingTransactions\" ||\n      type === \"alchemy_filteredFullPendingTransactions\"\n    ) {\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\n          \"alchemy_filteredNewFullPendingTransactions\" as any,\n          ...rest,\n        ),\n      );\n    }\n    return oldSubscribe(type as any, ...rest);\n  }) as any;\n}\n\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\nfunction suppressNoSubscriptionExistsWarning<T>(f: () => T): T {\n  const oldConsoleWarn = console.warn;\n  console.warn = (...args: unknown[]) => {\n    if (\n      typeof args[0] === \"string\" &&\n      args[0].includes(\" doesn't exist. Subscribing anyway.\")\n    ) {\n      return;\n    }\n    return oldConsoleWarn.apply(console, args);\n  };\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\nconst { subscription } = web3CoreSubscriptions as any;\nconst oldSubscriptionPrototypeValidateArgs =\n  subscription.prototype._validateArgs;\nsubscription.prototype._validateArgs = function (args: any) {\n  if (\n    [\n      \"alchemy_filteredNewFullPendingTransactions\",\n      \"alchemy_filteredPendingTransactions\",\n      \"alchemy_filteredFullPendingTransactions\",\n    ].includes(this.subscriptionMethod)\n  ) {\n    // This particular subscription type is allowed to have additional parameters\n  } else {\n    if (\n      [\n        \"alchemy_fullPendingTransactions\",\n        \"alchemy_newFullPendingTransactions\",\n      ].includes(this.subscriptionMethod)\n    ) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n\n    const validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\n\nfunction noop(): void {\n  // Nothing.\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}